
// Worker v9 (terrain-following + natural selection + speciation)
let entities=[],plants=[],devices=[];
let world={t:0,bounds:28,season:0,seasonSpeed:1,simCap:4000};
let randState=123456789; function rand(){randState^=randState<<13;randState^=randState>>>17;randState^=randState<<5;return (randState>>>0)/4294967296;}
function clamp01(v){return Math.max(0,Math.min(1,v));} function lerp(a,b,t){return a+(b-a)*t;}
// Map
const VERT=8.0; let map={size:96,heights:new Float32Array(96*96),biomes:new Uint8Array(96*96),step:0.3,waterLevel:-0.18};
function noise2d(x,y,seed){function h(n){const s=Math.sin(n*0.0007+seed*1e-6)*43758.5453;return s-Math.floor(s);}const xi=Math.floor(x),yi=Math.floor(y),xf=x-xi,yf=y-yi;function f(t){return t*t*(3-2*t);}const tl=h(xi*157+yi*311),tr=h((xi+1)*157+yi*311),bl=h(xi*157+(yi+1)*311),br=h((xi+1)*157+(yi+1)*311);const u=f(xf),v=f(yf);return lerp(lerp(tl,tr,u),lerp(bl,br,u),v);} function ridged(x,y,seed){const n=noise2d(x,y,seed);return 1-Math.abs(n*2-1);}
function generateMap(p){const N=p.size||96;map.size=N;map.heights=new Float32Array(N*N);map.biomes=new Uint8Array(N*N);map.step=p.step||0.3;
  const seed=(p.seed||12345)>>>0,slope=p.slope||1.1,mount=p.mount||1.0, rivers=!!p.rivers, set=p.biomes||['plains','forest','desert','wetland','tundra'];
  for(let z=0;z<N;z++){for(let x=0;x<N;x++){let h=(noise2d(x*0.05,z*0.05,seed)-0.5)*2.0;h+=(noise2d(x*0.015,z*0.015,seed+1337)-0.5)*1.2;h+=(ridged(x*0.12,z*0.12,seed+5555)-0.5)*2.0*mount;h*=slope;const q=Math.round(h/map.step)*map.step;h=0.7*q+0.3*h;map.heights[z*N+x]=h;}}let mn=1e9,mx=-1e9;for(let i=0;i<N*N;i++){const v=map.heights[i];if(v<mn)mn=v;if(v>mx)mx=v;}const rg=mx-mn||1;for(let i=0;i<N*N;i++){map.heights[i]=((map.heights[i]-mn)/rg)*1.2-0.6;}
  if(rivers){for(let z=0;z<N;z++){for(let x=0;x<N;x++){const r=ridged(x*0.05,z*0.05,seed+9909);const d=(1-r);const dig=Math.max(0,d-0.6)*0.55;const i=z*N+x;map.heights[i]-=dig;}}}
  function ok(n){return set.indexOf(n)>=0;}
  for(let z=0;z<N;z++){for(let x=0;x<N;x++){const i=z*N+x,e=map.heights[i], temp=1-Math.abs((z/N)*2-1), moist=noise2d(x*0.05,z*0.05,seed+4242);let b=0;if(e<map.waterLevel&&ok('wetland'))b=3;else if(temp<0.25&&ok('tundra'))b=4;else if(moist<0.28&&ok('desert'))b=2;else if(moist>0.65&&ok('forest'))b=1;else b=0;map.biomes[i]=b;}}
  const props=[];for(let z=0;z<N;z++){for(let x=0;x<N;x++){const i=z*N+x,e=map.heights[i],bx=(x/(N-1)-0.5)*(world.bounds*2),bz=(z/(N-1)-0.5)*(world.bounds*2),b=map.biomes[i],r=noise2d(x*0.3,z*0.3,seed+4444);if(b===1&&r>0.75&&e>map.waterLevel+0.02)props.push({type:'tree',x:bx,z:bz,y:e,s:0.8+noise2d(x*0.2,z*0.2,seed+1)});if(b===2&&r>0.82&&e>map.waterLevel+0.02)props.push({type:'cactus',x:bx,z:bz,y:e,s:0.8+noise2d(x*0.3,z*0.3,seed+2)});if(b===0&&r>0.85)props.push({type:'rock',x:bx,z:bz,y:e,s:0.6+noise2d(x*0.2,z*0.2,seed+3)});if(b===3&&r>0.78)props.push({type:'reed',x:bx,z:bz,y:e,s:0.7+noise2d(x*0.3,z*0.3,seed+4)});}} 
  postMessage({type:'map',payload:{size:N,heights:map.heights,biomes:map.biomes,step:map.step,vs:VERT,waterLevel:map.waterLevel,props}});}
function mapCoord(x,z){const N=map.size;const fx=((x/(world.bounds*2))+0.5)*(N-1),fz=((z/(world.bounds*2))+0.5)*(N-1);const xi=Math.max(0,Math.min(N-2,Math.floor(fx))),zi=Math.max(0,Math.min(N-2,Math.floor(fz)));return {N,xi,zi,i:zi*N+xi};}
function heightRawAt(x,z){const c=mapCoord(x,z);return map.heights[c.i];} function heightAtWorld(x,z){return heightRawAt(x,z)*VERT;}
function slopeAt(x,z){const c=mapCoord(x,z);const h=map.heights[c.i],hx=map.heights[c.i+1],hz=map.heights[c.i+c.N];return Math.sqrt((hx-h)*(hx-h)+(hz-h)*(hz-h));}
function biomeAt(x,z){const c=mapCoord(x,z);return map.biomes[c.i]||0;}
// Genes/species
let nextId=1,nextSpeciesId=1;const speciesHues={};let treeNodes=[];
function regSpecies(id,parent){const hue=(speciesHues[id]!==undefined?speciesHues[id]:rand());treeNodes.push({id,parent:parent||0,birth:world.t,hue});}
function gdist(a,b){return Math.abs(a.size-b.size)*0.8+Math.abs(a.speed-b.speed)*0.6+Math.abs(a.thermo-b.thermo)*0.8+Math.abs(a.climb-b.climb)*0.6+Math.abs(a.swim-b.swim)*0.6+Math.abs(a.social-b.social)*0.4+(a.diet!==b.diet?0.4:0);}
function newGenes(base){return {size:clamp01((base&&base.size||0.5)+(rand()*2-1)*0.05),speed:clamp01((base&&base.speed||0.5)+(rand()*2-1)*0.05),thermo:clamp01((base&&base.thermo||rand())+(rand()*2-1)*0.03),climb:clamp01((base&&base.climb||rand())+(rand()*2-1)*0.03),swim:clamp01((base&&base.swim||rand())+(rand()*2-1)*0.03),social:clamp01((base&&base.social||rand())+(rand()*2-1)*0.03),diet:(base&&base.diet!==undefined)?base.diet:(rand()<0.15?1:0)};}
function spawnEntity(id){const g=newGenes();const x=(rand()*2-1)*(world.bounds*0.6),z=(rand()*2-1)*(world.bounds*0.6);const sp=nextSpeciesId++;speciesHues[sp]=rand();regSpecies(sp,0);return {id,x,z,y:heightAtWorld(x,z)+0.35,vx:0,vz:0,yaw:0,energy:1.0,age:0.0,hydration:1.0,cooldown:rand()*6,genes:g,species:sp,mode:'walk',biomeExp:new Uint8Array(5)};}
function spawnPlant(){return {x:(rand()*2-1)*world.bounds*0.85,z:(rand()*2-1)*world.bounds*0.85,richness:0.6+rand()*0.4};}
function reproduce(p){const cg=newGenes(p.genes);const fav=p.biomeExp?p.biomeExp.indexOf(Math.max(...p.biomeExp)):0;const drift=gdist(cg,p.genes)+((fav===2||fav===3)?0.05:0);let sp=p.species;if(drift>0.22){sp=++nextSpeciesId;speciesHues[sp]=rand();regSpecies(sp,p.species);}entities.push({id:nextId++,x:p.x+(rand()*2-1)*0.5,z:p.z+(rand()*2-1)*0.5,y:heightAtWorld(p.x,p.z)+0.35,vx:0,vz:0,yaw:0,energy:0.6,hydration:0.8,age:0.0,cooldown:4+rand()*4,genes:cg,species:sp,mode:'walk',biomeExp:new Uint8Array(5)});}
// env
function comfortTempBase(z){return (Math.sin(z*0.07)*0.5+0.5);} function comfortTempWithDevices(x,z){let t=comfortTempBase(z);for(const d of devices){if(d.type!=='heater')continue;const dx=d.x-x,dz=d.z-z;const r2=dx*dx+dz*dz;const fall=Math.exp(-r2/(d.radius*d.radius));t=clamp01(t+d.power*0.25*fall);}return t;}
function plantRichnessAt(x,z){let best=0.0;for(const p of plants){const dx=p.x-x,dz=p.z-z;const d2=dx*dx+dz*dz;const e=p.richness/(1+d2*0.05);if(e>best)best=e;}for(const d of devices){if(d.type!=='sprinkler')continue;const dx=d.x-x,dz=d.z-z;const r2=dx*dx+dz*dz;const fall=Math.exp(-r2/(d.radius*d.radius));best+=d.power*0.8*fall;}return best;} function waterNear(x,z){return heightRawAt(x,z)<map.waterLevel?1.0:0.0;}
// spatial hash
const cell=3.0;let grid=new Map();function gkey(ix,iz){return (ix<<16)|(iz&0xffff);} function rebuild(){grid.clear();for(const e of entities){const ix=Math.floor((e.x+world.bounds)/cell),iz=Math.floor((e.z+world.bounds)/cell),k=gkey(ix,iz);if(!grid.has(k))grid.set(k,[]);grid.get(k).push(e);}} function near(x,z,r){const ix0=Math.floor((x+world.bounds)/cell),iz0=Math.floor((z+world.bounds)/cell),sp=Math.ceil(r/cell);const out=[];for(let dz=-sp;dz<=sp;dz++){for(let dx=-sp;dx<=sp;dx++){const k=gkey(ix0+dx,iz0+dz),arr=grid.get(k);if(!arr)continue;for(const e of arr){const dx2=e.x-x,dz2=e.z-z;if(dx2*dx2+dz2*dz2<=r*r)out.push(e);}}}return out;}
// lifecycle
function init(seed,count,cap){randState=seed>>>0;entities=[];plants=[];devices=[];nextId=1;nextSpeciesId=1;treeNodes=[];world.simCap=cap||world.simCap;generateMap({seed,size:96,step:0.3,slope:1.1,mount:1.0,rivers:true,biomes:['plains','forest','desert','wetland','tundra']});for(let i=0;i<count;i++)entities.push(spawnEntity(nextId++));for(let i=0;i<40;i++)plants.push(spawnPlant());snapshot();}
function tick(dt){world.t+=dt;world.season=(Math.sin(world.t*0.05*world.seasonSpeed)*0.5+0.5);rebuild();const maxS=3.0;
  for(let i=entities.length-1;i>=0;i--){const e=entities[i];e.age+=dt;e.cooldown-=dt;e.hydration-=0.005*dt*(1+(e.genes.diet===1?0.4:0));const s=3.0+e.genes.social*4.0;const ar=near(e.x,e.z,s);const b=biomeAt(e.x,e.z);e.biomeExp[b]=Math.min(255,e.biomeExp[b]+1);
    const targetT=e.genes.thermo,hereT=comfortTempWithDevices(e.x,e.z),comfort=1-Math.abs(hereT-targetT),food=plantRichnessAt(e.x,e.z),atWater=waterNear(e.x,e.z);
    const hunger=1-Math.max(0,Math.min(1,e.energy)),thirst=1-Math.max(0,Math.min(1,e.hydration));
    let U_forage=(e.genes.diet===0?0.6:0.25)*(food+0.2*comfort)+0.2*hunger; let U_drink=Math.max(0,thirst*0.8+(atWater?0.5:0)); let U_mate=(e.energy>1.2&&e.cooldown<=0)?(0.3+e.genes.social*0.4):0.0; let U_rest=(e.energy<0.3?0.6:0.1)*(1-comfort);
    let fleeX=0,fleeZ=0,chaseX=0,chaseZ=0,prey=0; for(const o of ar){if(o===e)continue;const dx=o.x-e.x,dz=o.z-e.z;const d=Math.sqrt(dx*dx+dz*dz)+1e-6; if(e.genes.diet===0&&o.genes.diet===1&&d<s){U_rest=0;U_mate=0;fleeX-=dx/d*(1.5-d/s);fleeZ-=dz/d*(1.5-d/s);} if(e.genes.diet===1&&o.genes.diet===0&&d<s){chaseX+=dx/d*(1.5-d/s);chaseZ+=dz/d*(1.5-d/s);prey++;}}
    if(prey>0)U_forage=Math.max(U_forage,0.25);
    let ax=0,az=0; let sepX=0,sepZ=0,aliX=0,aliZ=0,cohX=0,cohZ=0, nali=0,ncoh=0; for(const o of ar){if(o===e)continue;const dx=e.x-o.x,dz=e.z-o.z;const d=Math.sqrt(dx*dx+dz*dz)+1e-6; if(d<1.0){const f=(1.0-d);sepX+=(dx/d)*f;sepZ+=(dz/d)*f;} if(o.genes.diet===e.genes.diet){aliX+=o.vx;aliZ+=o.vz;nali++;cohX+=o.x;cohZ+=o.z;ncoh++;}} if(nali>0){aliX/=nali;aliZ/=nali;} if(ncoh>0){cohX=(cohX/ncoh-e.x);cohZ=(cohZ/ncoh-e.z);} ax+=sepX*1.6+aliX*0.12*e.genes.social+cohX*0.08*e.genes.social; az+=sepZ*1.6+aliZ*0.12*e.genes.social+cohZ*0.08*e.genes.social;
    const gx=plantRichnessAt(e.x+0.8,e.z)-plantRichnessAt(e.x-0.8,e.z),gz=plantRichnessAt(e.x,e.z+0.8)-plantRichnessAt(e.x,e.z-0.8); if(e.genes.diet===0){ax+=gx*0.9;az+=gz*0.9;} if(thirst>0.3){const hR=heightRawAt(e.x+0.6,e.z)-heightRawAt(e.x-0.6,e.z), hU=heightRawAt(e.x,e.z+0.6)-heightRawAt(e.x,e.z-0.6); ax+=-hR*0.9*thirst; az+=-hU*0.9*thirst;}
    ax+=chaseX*1.2+fleeX*1.7; az+=chaseZ*1.2+fleeZ*1.7;
    const sl=slopeAt(e.x,e.z); const avoidSlope=Math.max(0,sl-(0.10+0.15*e.genes.climb)); const inWater=heightRawAt(e.x,e.z)<map.waterLevel; e.mode=inWater?'swim':'walk';
    const acc=0.6+e.genes.speed*0.9; e.vx+=ax*acc*dt; e.vz+=az*acc*dt;
    const damp=inWater?(1-0.45*dt):(1-0.65*dt); e.vx*=damp*(1-avoidSlope*0.6)*(1-(inWater?(1-e.genes.swim)*0.7:0)); e.vz*=damp*(1-avoidSlope*0.6)*(1-(inWater?(1-e.genes.swim)*0.7:0));
    const sp2=e.vx*e.vx+e.vz*e.vz, sp=Math.sqrt(sp2),limit=inWater?2.0:maxS; if(sp>limit){const s=limit/sp;e.vx*=s;e.vz*=s;}
    e.x+=e.vx*dt; e.z+=e.vz*dt; const B=world.bounds-1.0; if(e.x<-B){e.x=-B;e.vx*=-0.8;} if(e.x>B){e.x=B;e.vx*=-0.8;} if(e.z<-B){e.z=-B;e.vz*=-0.8;} if(e.z>B){e.z=B;e.vz*=-0.8;}
    const gY=heightAtWorld(e.x,e.z); e.y=gY+(inWater?0.15:0.35)+Math.sin((e.x+e.z+world.t)*(inWater?0.3:0.7))*(inWater?0.05:0.06); if(avoidSlope>0.6){e.vx-=Math.sign(e.vx)*0.02; e.vz-=Math.sign(e.vz)*0.02;}
    const biome=b; const biomeMul=(biome===2?0.6:(biome===3?1.3:(biome===4?0.7:1.0))); const intake=(e.genes.diet===0)?(0.1+0.7*plantRichnessAt(e.x,e.z)*biomeMul+0.2*comfort):(0.12+0.4*comfort); const moveCost=(0.002+0.0006*sp2)*(0.8+e.genes.size*0.6)*(1+avoidSlope*0.8+(inWater?(1-e.genes.swim)*0.9:0)); const basal=0.0008+0.0006*e.genes.size+(e.genes.diet===1?0.0006:0); e.energy+=(intake*dt)-(moveCost+basal);
    if(inWater)e.hydration=Math.max(e.hydration,Math.min(1.0,e.hydration+0.5*dt)); if(e.genes.diet===1){for(const o of ar){if(o===e||o.genes.diet!==0)continue;const dx=o.x-e.x,dz=o.z-e.z,d2=dx*dx+dz*dz;if(d2<0.25*0.25){e.energy+=0.6;o.energy-=1.0;}}}
    if(entities.length<world.simCap&&e.cooldown<=0&&e.energy>1.5&&e.hydration>0.3){e.cooldown=6+rand()*6;e.energy-=0.6;reproduce(e);} if(e.energy<-0.2||e.age>300){entities.splice(i,1);continue;}
    e.yaw=Math.atan2(e.vx,e.vz);
  } for(const p of plants){p.x+=Math.sin(world.t*0.05+p.x)*0.002;p.z+=Math.cos(world.t*0.05+p.z)*0.002;}}
function snapshot(){const list=new Array(entities.length);for(let i=0;i<entities.length;i++){const e=entities[i],hue=(speciesHues[e.species]!==undefined?speciesHues[e.species]:0.35);list[i]={id:e.id,x:e.x,y:e.y,z:e.z,size:e.genes.size,hue:hue,yaw:e.yaw,diet:e.genes.diet,mode:e.mode,vx:e.vx,vz:e.vz};}postMessage({type:'state',payload:{entities:list,world,devices}});}
let timer=null; onmessage=(e)=>{try{const t=e.data.type,p=e.data.payload; if(t==='init'){init((p&&p.seed)||1,(p&&p.entityCount)||200,p&&p.simCap||4000); if(timer)clearInterval(timer); const dt=0.1; timer=setInterval(()=>{tick(dt);snapshot();},100);} else if(t==='seasonSpeed'){world.seasonSpeed=p||1.0;} else if(t==='placeDevice'){devices.push({type:p.type,x:p.x,z:p.z,power:1.0,radius:5.0});} else if(t==='pickSelect'){let best=null,bd2=1e9;for(const ent of entities){const dx=ent.x-p.x,dz=ent.z-p.z,d2=dx*dx+dz*dz;if(d2<bd2){bd2=d2;best=ent;}} if(best)postMessage({type:'selected',payload:{x:best.x,z:best.z}});} else if(t==='regenMap'){generateMap(p||{seed:Date.now(),size:96,step:0.3,slope:1.1,mount:1.0,rivers:true});} else if(t==='getTree'){postMessage({type:'tree',payload:{nodes:treeNodes}});} else if(t==='selectSpecies'){postMessage({type:'rpgReady',payload:{species:p.species}});} else if(t==='simCap'){world.simCap=p||world.simCap;} }catch(err){postMessage({type:'error',payload:''+err});}};
